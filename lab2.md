# lab2
## ch4
1. 将代码布局调整了下，和ch3一样，重新更换了TaskInfo的位置，从process.rs移到了task.rs，使得结构更加清晰,相应的需要修改一些地方。
2. 对于sys_get_time和sys_task_info主要在于translated_byte_buffer函数的使用，这里查看了答案（主要一开始没看懂这个函数的返回值），然后大概思路就是先把用户空间传过来的_ts和_ti的虚拟地址转化为物理地址，然后由于内核地址是直接映射，因此可以先通过申请地址存入需要的数据，然后通过指针复制的操作将需要传输的数据的物理地址赋值。
3. 对于mmap和munmap，感觉有点抽象，勉勉强强做完了。首先是mmap，需要对传输数据的合理性进行判断（基本提示都写了），然后就是注意port和mappermission的转化，然后就是通过mapareas判断区域是否存在，最后就通过已有函数就申请空间即可。对于munmap则麻烦一点，这里查看了答案，简单来说就是通过mapareas判断区域是否正在使用，然后对于areas进行unmap和remove操作。

## 简答
1. 页表由 ppn+flag组成，
   flag:有效位（V）、读写权限位（R\W\X）、用户访问权限位（U）、访问位和脏位（A\D）、保留位
2. 1. 没有对应物理地址的虚拟地址
   2. stval:保存造成异常的指令、sepc:保存造成异常的指令，缺页一般要重新执行这条指令、satp:记录页表信息、status:记录处理器的状态信息
   3. 减少了IO，加快了启动速度
   4. (10G/4k)/512/512+(10G/4k)/512+(10G/4k)=2M
   5. 可以在页表的标识位加入是否lazy处理，当进程刚开始的时候，为程序的所有虚拟地址空间建立页表项，但页表项初始时不指向物理内存，lazy标识符为0。当访问虚拟地址的时候，如果页表项lazy标识符为0，则说明缺页，需要进行加载。
   6. 使用保留的标识位进行记录
3. 1. 对于用户态到内核态的切换，只需要调整pc的值即可，而对于进程的切换则需要通过satp切换页表
   2. 可以通过设置符号位，比如说U位
   3. 进入内核态时不需要切换页表，效率高
   4. 双页表：进行内核态、进程切换 
      单页表：进程切换

## 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我未与其他人就（与本次实验相关的）做过交流。但我参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
https://sjodqtoogh.feishu.cn/docx/ZoqBdmcmAoXi9yxZUkucMmxBnzg
我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。